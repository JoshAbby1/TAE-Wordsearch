<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Word Search — nortydigitalcrew</title>
<style>
  :root{--bg:#777;--panel:rgba(255,255,255,0.18);--cell-size:40px}
  html,body{height:100%;margin:0}
  body{
    background:var(--bg);
    font-family:Arial,Helvetica,sans-serif;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    overflow:hidden;
    position:relative;
  }

  /* full-screen yellow paint splatters */
  body::before{
    content:"";
    position:fixed; inset:0; z-index:0;
    background-image:
      radial-gradient(circle at 10% 20%, rgba(255,235,0,0.55) 0%, rgba(255,235,0,0) 55%),
      radial-gradient(circle at 75% 30%, rgba(255,235,0,0.45) 0%, rgba(255,235,0,0) 60%),
      radial-gradient(circle at 40% 80%, rgba(255,235,0,0.38) 0%, rgba(255,235,0,0) 60%);
    background-repeat:no-repeat;
    pointer-events:none;
    opacity:0.45;
    filter:blur(2px);
  }

  /* Top instruction (moved to top) */
  .instruction {
    z-index:2;
    text-align:center;
    margin-top:12px;
    font-size:16px;
    font-weight:700;
    color:#fff;
    text-shadow:1px 1px 2px rgba(0,0,0,0.6);
  }

  header{z-index:2; text-align:center; margin-top:8px}
  h1{margin:4px 0 0 0;font-size:26px;color:#fff;letter-spacing:1px}
  .credit{margin-top:4px;color:#fff;opacity:.95;font-size:14px}

  #wordsWrap{z-index:2; margin-top:12px; width:95%; max-width:980px; display:flex; justify-content:center}
  #wordsList{
    background:var(--panel);
    padding:10px 14px;
    border-radius:10px;
    color:white;
    font-weight:700;
    font-size:15px;
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:center;
  }
  .wordItem{padding:4px 8px;border-radius:6px;background:transparent;color:#fff}
  .wordFound{ text-decoration:line-through; color:#c8ffc8; background:transparent }

  /* the main area that centers the grid vertically in the tall 9:16 view */
  #gridArea{
    z-index:2;
    width:100%;
    flex:1 1 auto;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:8px 8px 18px 8px;
    box-sizing:border-box;
  }

  /* grid panel */
  #grid{
    display:grid;
    background:var(--panel);
    padding:12px;
    border-radius:12px;
    box-shadow:0 8px 30px rgba(0,0,0,0.35);
    touch-action: manipulation;
  }

  .cell{
    width:var(--cell-size);
    height:var(--cell-size);
    display:flex;
    align-items:center;
    justify-content:center;
    background:#fff;
    border-radius:6px;
    user-select:none;
    -webkit-user-select:none;
    font-weight:800;
    font-size:calc(var(--cell-size) * 0.48);
    color:#222;
    cursor:pointer;
    transition:background .12s, transform .06s;
  }
  .cell:active{ transform:scale(.98) }

  .cell.highlight{ background:#ffe66d }    /* temporary selection highlight */
  .cell.found{ background:#6cff6c !important; color:#000 } /* final found */

  footer{ z-index:2; color:#fff; font-size:13px; margin-bottom:12px }
  .small{ font-size:12px; opacity:.85 }

  @media (min-width:900px){
    h1{font-size:30px}
  }
</style>
</head>
<body>
  <!-- top instruction moved to very top -->
  <div class="instruction">Tap the first letter and the last letter to select a word</div>

  <header>
    <h1>WORD SEARCH</h1>
    <div class="credit">made by @nortydigitalcrew</div>
  </header>

  <div id="wordsWrap">
    <div id="wordsList">Loading words…</div>
  </div>

  <div id="gridArea">
    <div id="grid" role="grid" aria-label="Word search grid"></div>
  </div>

  <footer><span id="levelLabel">Level 1</span> <span class="small"> — tap start/end to select</span></footer>

<script>
/* ---------- CONFIG & STATE ---------- */
const MASTER_WORDS = [
  "DOG","SUN","CAR","HAT","TREE","BOOK","MOON","STAR","FROG","HILL",
  "PHONE","BRICK","CHAIR","SPOON","BREAD","WATER","MONEY","STONE",
  "FLOWER","PLANET","ROCKET","PUZZLE","JUNGLE","MONKEY","DINOSAUR","NOTEBOOK",
  "SANDWICH","BACKPACK","PLAYGROUND","AEROPLANE","WATERMELON","CELEBRATION",
  "TELEPHONE","COMPUTER","KEYBOARD","MOUNTAIN","ELEPHANT","KANGAROO","TELESCOPE",
  "CAMERA","WINDOW","GARDEN","BICYCLE","CUPBOARD","PICTURE","NETWORK"
];

const START_GRID_SIZE = 12;
const MAX_GRID_SIZE = 18;
const MAX_WORDS_PER_LEVEL = 10;

let gridSize = START_GRID_SIZE;
let grid = [];
let level = 1;
let usedWords = new Set();
let currentWords = [];
let foundWords = new Set();
let firstSelected = null;

/* UI refs */
const gridEl = document.getElementById('grid');
const wordsListEl = document.getElementById('wordsList');
const levelLabel = document.getElementById('levelLabel');

/* helpers */
const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const rand = n => Math.floor(Math.random()*n);
const shuffle = arr => { for(let i=arr.length-1;i>0;i--){const j=rand(i+1);[arr[i],arr[j]]=[arr[j],arr[i]];} };

/* compute cell size to fit tall 9:16 without scrolling */
function computeCellSize(size){
  const vh = window.innerHeight;
  const headerH = Math.min(120, vh*0.13);
  const wordsH = Math.min(160, vh*0.14);
  const footerH = 60;
  const availableH = vh - (headerH + wordsH + footerH + 40);
  const cellByHeight = Math.floor(availableH / size);
  const availableW = window.innerWidth - 28;
  const cellByWidth = Math.floor(availableW / size);
  const final = Math.max(20, Math.min(cellByHeight, cellByWidth));
  return final;
}

/* ---------- GRID & PLACEMENT ---------- */
function clearGrid(){
  grid = Array.from({length:gridSize}, ()=>Array.from({length:gridSize}, ()=>""));
}

function attemptPlaceWordWithGrid(word, maxAttempts=600){
  const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
  for(let attempt=0; attempt<maxAttempts; attempt++){
    const [dx,dy] = dirs[rand(dirs.length)];
    const minX = dx===-1 ? word.length-1 : 0;
    const maxX = dx===1 ? gridSize - word.length : gridSize - 1;
    const minY = dy===-1 ? word.length-1 : 0;
    const maxY = dy===1 ? gridSize - word.length : gridSize - 1;
    if(minX > maxX || minY > maxY) continue;
    const x = minX + rand(maxX - minX + 1);
    const y = minY + rand(maxY - minY + 1);
    let ok = true;
    for(let i=0;i<word.length;i++){
      const nx = x + i*dx, ny = y + i*dy;
      const ch = grid[ny][nx];
      if(ch !== "" && ch !== word[i]) { ok=false; break; }
    }
    if(!ok) continue;
    for(let i=0;i<word.length;i++){
      const nx = x + i*dx, ny = y + i*dy;
      grid[ny][nx] = word[i];
    }
    return true;
  }
  return false;
}

function placeAllWordsOrResize(words){
  clearGrid();
  for(const w of words){
    const ok = attemptPlaceWordWithGrid(w, 800);
    if(!ok) return false;
  }
  // fill empties
  for(let r=0;r<gridSize;r++) for(let c=0;c<gridSize;c++) if(grid[r][c]==="") grid[r][c] = LETTERS[rand(LETTERS.length)];
  return true;
}

/* ---------- WORD SELECTION & HIGHLIGHT ---------- */
function renderWordsList(){
  wordsListEl.innerHTML = "";
  for(const w of currentWords){
    const d = document.createElement('div');
    d.className = 'wordItem';
    d.id = 'word-' + w;
    d.textContent = w;
    wordsListEl.appendChild(d);
  }
}

function renderGrid(){
  // compute cell size and apply
  const cellSize = computeCellSize(gridSize);
  document.documentElement.style.setProperty('--cell-size', cellSize + 'px');
  gridEl.style.gridTemplateColumns = `repeat(${gridSize}, ${cellSize}px)`;
  gridEl.style.gridTemplateRows = `repeat(${gridSize}, ${cellSize}px)`;
  gridEl.innerHTML = "";
  for(let r=0;r<gridSize;r++){
    for(let c=0;c<gridSize;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.row = r;
      cell.dataset.col = c;
      cell.textContent = grid[r][c];
      cell.addEventListener('click', onCellClick);
      gridEl.appendChild(cell);
    }
  }
}

/* click-first-then-last selection */
function onCellClick(e){
  const el = e.currentTarget;
  if(!firstSelected){
    firstSelected = el;
    el.classList.add('highlight');
    return;
  }
  // second click
  const r1 = parseInt(firstSelected.dataset.row), c1 = parseInt(firstSelected.dataset.col);
  const r2 = parseInt(el.dataset.row), c2 = parseInt(el.dataset.col);
  const dr = r2 - r1, dc = c2 - c1;
  const steps = Math.max(Math.abs(dr), Math.abs(dc));
  if(steps === 0){
    firstSelected.classList.remove('highlight');
    firstSelected = null;
    return;
  }
  const stepR = dr === 0 ? 0 : dr / steps;
  const stepC = dc === 0 ? 0 : dc / steps;
  if(!Number.isInteger(stepR) || !Number.isInteger(stepC)){
    firstSelected.classList.remove('highlight');
    firstSelected = el;
    el.classList.add('highlight');
    return;
  }
  // collect line
  const collected = [];
  for(let i=0;i<=steps;i++){
    const rr = r1 + i*stepR, cc = c1 + i*stepC;
    if(rr<0||rr>=gridSize||cc<0||cc>=gridSize){ collected.length=0; break; }
    const selector = `.cell[data-row="${rr}"][data-col="${cc}"]`;
    const cellEl = document.querySelector(selector);
    if(!cellEl){ collected.length=0; break; }
    collected.push(cellEl);
  }
  // clear old highlights
  document.querySelectorAll('.cell.highlight').forEach(x => x.classList.remove('highlight'));
  collected.forEach(x => x.classList.add('highlight'));
  // build string & check
  const letters = collected.map(c => c.textContent).join('');
  const rev = letters.split('').reverse().join('');
  const match = currentWords.find(w => (w === letters || w === rev) && !foundWords.has(w));
  if(match){
    // mark found everywhere and cross off
    highlightAllOccurrences(match);
    foundWords.add(match);
    const wordEl = document.getElementById('word-' + match);
    if(wordEl){ wordEl.classList.add('wordFound'); wordEl.style.textDecoration = 'line-through'; wordEl.style.color = '#bfffbf'; }
    // check completion
    if(foundWords.size === currentWords.length){
      setTimeout(() => nextLevel(), 850);
    }
  }
  firstSelected = null;
}

/* search and permanently mark every occurrence of a word */
function highlightAllOccurrences(word){
  const rev = word.split('').reverse().join('');
  const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
  for(let r=0;r<gridSize;r++){
    for(let c=0;c<gridSize;c++){
      for(const [dx,dy] of dirs){
        let s = "", cells = [];
        for(let i=0;i<word.length;i++){
          const rr = r + i*dy, cc = c + i*dx;
          if(rr<0||rr>=gridSize||cc<0||cc>=gridSize){ s=""; break; }
          s += grid[rr][cc];
          const el = document.querySelector(`.cell[data-row="${rr}"][data-col="${cc}"]`);
          cells.push(el);
        }
        if(s === word || s === rev){
          cells.forEach(el => el && el.classList.add('found'));
        }
      }
    }
  }
}

/* ---------- LEVEL / WORD SELECTION ---------- */
function chooseWordsForLevel(){
  const minLen = 1;
  let maxLen = level === 1 ? 5 : level === 2 ? 8 : level === 3 ? 10 : 12;
  const count = Math.min(MAX_WORDS_PER_LEVEL, 4 + level);
  let pool = MASTER_WORDS.filter(w => !usedWords.has(w) && w.length >= minLen && w.length <= maxLen);
  shuffle(pool);
  if(pool.length < count){
    // include previously used words if pool too small (avoid empty)
    const extra = MASTER_WORDS.filter(w => !pool.includes(w) && w.length >= minLen && w.length <= maxLen);
    shuffle(extra);
    pool = pool.concat(extra);
  }
  return pool.slice(0, count);
}

function setupPuzzleForLevel(){
  let chosen = chooseWordsForLevel();
  if(chosen.length === 0) return false;
  currentWords = chosen;
  currentWords.forEach(w => usedWords.add(w));
  // attempt placing: try increasing grid until success
  let tryGrid = Math.max(START_GRID_SIZE, gridSize);
  while(tryGrid <= MAX_GRID_SIZE){
    gridSize = tryGrid;
    if(placeAllWordsOrResize(currentWords)) {
      foundWords.clear();
      return true;
    }
    tryGrid++;
  }
  return false;
}

function nextLevel(){
  level++;
  levelLabel.textContent = 'Level ' + level;
  const ok = setupPuzzleForLevel();
  if(!ok){
    // fallback: reset usedWords and try again
    usedWords.clear();
    setupPuzzleForLevel();
  }
  renderWordsList();
  renderGrid();
}

/* ---------- INIT & START ---------- */
function startNewGame(){
  gridSize = START_GRID_SIZE;
  usedWords.clear();
  level = 1;
  levelLabel.textContent = 'Level ' + level;
  setupPuzzleForLevel();
  renderWordsList();
  renderGrid();
}

window.addEventListener('resize', () => {
  renderGrid();
});

startNewGame();
</script>
</body>
</html>