<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Word Search Game</title>
<style>
    body {
        margin: 0;
        padding: 0;
        background: #777;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: Arial, sans-serif;
        user-select: none;
        position: relative;
    }

    /* Paint splatter background */
    body::before {
        content: "";
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background-image:
           radial-gradient(circle, yellow 0%, transparent 60%),
           radial-gradient(circle, yellow 0%, transparent 70%),
           radial-gradient(circle, yellow 0%, transparent 65%);
        background-size: 300px 300px, 250px 250px, 200px 200px;
        background-position: 15% 20%, 70% 40%, 40% 80%;
        opacity: 0.4;
        pointer-events: none;
    }

    #title {
        font-size: 40px;
        margin-top: 20px;
        font-weight: bold;
        color: white;
        z-index: 20;
    }

    #wordlist {
        margin: 10px;
        padding: 10px;
        background: rgba(255,255,255,0.2);
        border-radius: 8px;
        color: white;
        font-size: 20px;
        text-align: center;
    }

    #grid {
        display: grid;
        gap: 4px;
        margin-top: 20px;
        z-index: 10;
    }

    .cell {
        width: 40px;
        height: 40px;
        background: white;
        color: black;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 22px;
        font-weight: bold;
        border-radius: 4px;
    }

    .selected {
        background: yellow;
    }

    .found {
        background: #00c400 !important;
        color: black;
    }
</style>
</head>
<body>

<div id="title">WORD SEARCH</div>
<div id="wordlist">Loading...</div>
<div id="grid"></div>

<script>
let gridSize = 10;
let grid = [];
let selectedCells = [];
let foundWords = [];
let currentWords = [];
let level = 1;

function generateWords() {
    const baseWords = [
        "CAT","DOG","TREE","MILK","MOON","STAR","FROG","HILL","WOLF","SNAKE",
        "PHONE","BRICK","CHAIR","SPOON","BREAD","WATER","MONEY","STONE",
        "FLOWER","PLANET","ROCKET","PUZZLE","JUNGLE","MONKEY"
    ];

    const wordLength = Math.min(4 + level, 10);  
    const filtered = baseWords.filter(w => w.length <= wordLength);

    shuffle(filtered);
    return filtered.slice(0, 5);
}

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

function generateGrid() {
    grid = Array(gridSize)
        .fill(null)
        .map(() => Array(gridSize).fill(""));

    currentWords = generateWords();
    foundWords = [];

    placeWords();
    fillRandomLetters();
    renderGrid();
    updateWordList();
}

function placeWords() {
    for (const word of currentWords) {
        let placed = false;
        while (!placed) {
            const x = Math.floor(Math.random() * gridSize);
            const y = Math.floor(Math.random() * gridSize);

            const directions = [
                [1,0], [-1,0], [0,1], [0,-1],
                [1,1], [-1,-1], [1,-1], [-1,1]
            ];
            shuffle(directions);

            for (const [dx,dy] of directions) {
                if (canPlace(word, x, y, dx, dy)) {
                    for (let i = 0; i < word.length; i++) {
                        grid[y + i*dy][x + i*dx] = word[i];
                    }
                    placed = true;
                    break;
                }
            }
        }
    }
}

function canPlace(word, x, y, dx, dy) {
    for (let i = 0; i < word.length; i++) {
        const nx = x + i*dx;
        const ny = y + i*dy;
        if (nx < 0 || nx >= gridSize || ny < 0 || ny >= gridSize) return false;
        if (grid[ny][nx] !== "" && grid[ny][nx] !== word[i]) return false;
    }
    return true;
}

function fillRandomLetters() {
    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            if (grid[y][x] === "") {
                grid[y][x] = letters[Math.floor(Math.random()*letters.length)];
            }
        }
    }
}

function renderGrid() {
    const g = document.getElementById("grid");
    g.style.gridTemplateColumns = `repeat(${gridSize}, 40px)`;
    g.innerHTML = "";

    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.innerText = grid[y][x];
            cell.dataset.x = x;
            cell.dataset.y = y;

            cell.addEventListener("click", () => handleSelect(cell));

            g.appendChild(cell);
        }
    }
}

function updateWordList() {
    document.getElementById("wordlist").innerHTML =
        currentWords.map(w =>
            foundWords.includes(w)
            ? `<span style="text-decoration: line-through; color:#a0ffa0;">${w}</span>`
            : w
        ).join(" â€¢ ");
}

function handleSelect(cell) {
    cell.classList.add("selected");
    selectedCells.push(cell);

    if (selectedCells.length >= 2) checkSelection();
}

function checkSelection() {
    const letters = selectedCells.map(c => c.innerText).join("");
    const reversed = letters.split("").reverse().join("");

    const matchedWord = currentWords.find(
        w => w === letters || w === reversed
    );

    if (matchedWord) {
        foundWords.push(matchedWord);
        highlightFound();
        updateWordList();

        if (foundWords.length === currentWords.length) {
            setTimeout(nextLevel, 800);
        }
    }

    setTimeout(() => {
        selectedCells.forEach(c => c.classList.remove("selected"));
        selectedCells = [];
    }, 200);
}

function highlightFound() {
    for (let word of foundWords) {
        highlightWordInGrid(word);
    }
}

function highlightWordInGrid(word) {
    const full = word;
    const reversed = word.split("").reverse().join("");

    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {

            const tries = [
                [1,0],[-1,0],[0,1],[0,-1],
                [1,1],[-1,-1],[1,-1],[-1,1]
            ];

            for (const [dx,dy] of tries) {
                let collect = "";

                for (let i = 0; i < full.length; i++) {
                    const nx = x + i*dx;
                    const ny = y + i*dy;
                    if (nx < 0 || nx >= gridSize || ny < 0 || ny >= gridSize) break;
                    collect += grid[ny][nx];
                }

                if (collect === full || collect === reversed) {
                    // highlight
                    for (let i = 0; i < full.length; i++) {
                        const nx = x + i*dx;
                        const ny = y + i*dy;
                        const cell = document.querySelector(
                            `.cell[data-x="${nx}"][data-y="${ny}"]`
                        );
                        cell.classList.add("found");
                    }
                }
            }
        }
    }
}

function nextLevel() {
    level++;
    gridSize = Math.min(14, gridSize + 1);  
    generateGrid();
}

generateGrid();
</script>

</body>
</html>